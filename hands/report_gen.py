"""
╔══════════════════════════════════════════════════════════════╗
║      TARS — Report Generator (Excel & PDF)                   ║
╠══════════════════════════════════════════════════════════════╣
║  Professional report generation for TARS to attach to        ║
║  emails or save locally. Supports:                           ║
║    • Excel (.xlsx) — tables, formatting, charts              ║
║    • PDF — structured reports with headers, tables, text     ║
║    • CSV — simple data export                                ║
╚══════════════════════════════════════════════════════════════╝
"""

import os
import csv
import json
import logging
import tempfile
from datetime import datetime

log = logging.getLogger("tars.report_gen")

# Output directory for generated reports
REPORT_DIR = os.path.expanduser("~/Documents/TARS_Reports")
os.makedirs(REPORT_DIR, exist_ok=True)


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#  Excel Report Generation
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

def generate_excel(title, headers, rows, filename=None, sheet_name="Report", 
                   summary=None, auto_width=True):
    """Generate a professional Excel report.
    
    Args:
        title: Report title (appears as header row)
        headers: List of column headers, e.g. ["Name", "Email", "Status"]
        rows: List of row data, each row is a list. e.g. [["Alice", "a@b.com", "Active"], ...]
        filename: Output filename (auto-generated if None)
        sheet_name: Excel sheet name
        summary: Optional dict of summary key-value pairs shown below the table
        auto_width: Auto-adjust column widths
    
    Returns:
        dict with success, path, and content message
    """
    try:
        from openpyxl import Workbook
        from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
        from openpyxl.utils import get_column_letter
    except ImportError:
        return {"success": False, "error": True, 
                "content": "openpyxl not installed. Run: pip install openpyxl"}
    
    wb = Workbook()
    ws = wb.active
    ws.title = sheet_name
    
    # ── Styles ──
    title_font = Font(name="Helvetica Neue", size=16, bold=True, color="1A1A2E")
    header_font = Font(name="Helvetica Neue", size=11, bold=True, color="FFFFFF")
    header_fill = PatternFill(start_color="1A1A2E", end_color="1A1A2E", fill_type="solid")
    data_font = Font(name="Helvetica Neue", size=10)
    alt_fill = PatternFill(start_color="F0F0F5", end_color="F0F0F5", fill_type="solid")
    summary_key_font = Font(name="Helvetica Neue", size=10, bold=True)
    thin_border = Border(
        left=Side(style="thin", color="D0D0D0"),
        right=Side(style="thin", color="D0D0D0"),
        top=Side(style="thin", color="D0D0D0"),
        bottom=Side(style="thin", color="D0D0D0"),
    )
    
    # ── Title Row ──
    ws.merge_cells(start_row=1, start_column=1, end_row=1, end_column=max(len(headers), 1))
    title_cell = ws.cell(row=1, column=1, value=title)
    title_cell.font = title_font
    title_cell.alignment = Alignment(horizontal="left", vertical="center")
    ws.row_dimensions[1].height = 35
    
    # ── Subtitle (date) ──
    ws.merge_cells(start_row=2, start_column=1, end_row=2, end_column=max(len(headers), 1))
    date_cell = ws.cell(row=2, column=1, value=f"Generated by TARS · {datetime.now().strftime('%B %d, %Y at %I:%M %p')}")
    date_cell.font = Font(name="Helvetica Neue", size=9, italic=True, color="888888")
    ws.row_dimensions[2].height = 20
    
    # ── Blank row ──
    start_row = 4
    
    # ── Headers ──
    for col_idx, header in enumerate(headers, 1):
        cell = ws.cell(row=start_row, column=col_idx, value=header)
        cell.font = header_font
        cell.fill = header_fill
        cell.alignment = Alignment(horizontal="center", vertical="center")
        cell.border = thin_border
    ws.row_dimensions[start_row].height = 28
    
    # ── Data Rows ──
    for row_idx, row_data in enumerate(rows, start_row + 1):
        for col_idx, value in enumerate(row_data, 1):
            cell = ws.cell(row=row_idx, column=col_idx, value=value)
            cell.font = data_font
            cell.border = thin_border
            cell.alignment = Alignment(vertical="center")
            # Alternating row colors
            if (row_idx - start_row) % 2 == 0:
                cell.fill = alt_fill
    
    # ── Summary Section ──
    if summary:
        summary_start = start_row + len(rows) + 2
        ws.cell(row=summary_start, column=1, value="Summary").font = Font(
            name="Helvetica Neue", size=12, bold=True, color="1A1A2E")
        for i, (key, val) in enumerate(summary.items()):
            ws.cell(row=summary_start + 1 + i, column=1, value=key).font = summary_key_font
            ws.cell(row=summary_start + 1 + i, column=2, value=val).font = data_font
    
    # ── Auto-width ──
    if auto_width:
        for col_idx in range(1, len(headers) + 1):
            max_len = len(str(headers[col_idx - 1]))
            for row_data in rows:
                if col_idx - 1 < len(row_data):
                    max_len = max(max_len, len(str(row_data[col_idx - 1])))
            ws.column_dimensions[get_column_letter(col_idx)].width = min(max_len + 4, 50)
    
    # ── Save ──
    if not filename:
        safe_title = "".join(c if c.isalnum() or c in " _-" else "_" for c in title)
        filename = f"{safe_title}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
    
    filepath = os.path.join(REPORT_DIR, filename)
    wb.save(filepath)
    log.info(f"Excel report generated: {filepath}")
    
    return {
        "success": True,
        "path": filepath,
        "content": f"Excel report '{title}' saved to {filepath} ({len(rows)} rows, {len(headers)} columns)"
    }


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#  PDF Report Generation
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

def generate_pdf(title, sections, filename=None, table_data=None):
    """Generate a professional PDF report.
    
    Args:
        title: Report title
        sections: List of dicts, each with:
            - "heading": Section heading (str)
            - "body": Section text content (str)
        filename: Output filename (auto-generated if None)
        table_data: Optional dict with:
            - "headers": list of column headers
            - "rows": list of row lists
    
    Returns:
        dict with success, path, and content message
    """
    try:
        from reportlab.lib.pagesizes import letter
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.colors import HexColor
        from reportlab.lib.units import inch
        from reportlab.lib import colors
        from reportlab.platypus import (SimpleDocTemplate, Paragraph, Spacer, 
                                         Table, TableStyle, HRFlowable)
    except ImportError:
        return {"success": False, "error": True,
                "content": "reportlab not installed. Run: pip install reportlab"}
    
    if not filename:
        safe_title = "".join(c if c.isalnum() or c in " _-" else "_" for c in title)
        filename = f"{safe_title}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
    
    filepath = os.path.join(REPORT_DIR, filename)
    
    doc = SimpleDocTemplate(
        filepath, pagesize=letter,
        leftMargin=0.75*inch, rightMargin=0.75*inch,
        topMargin=0.75*inch, bottomMargin=0.75*inch
    )
    
    # ── Styles ──
    styles = getSampleStyleSheet()
    styles.add(ParagraphStyle(
        name="TARSTitle",
        fontName="Helvetica-Bold",
        fontSize=22,
        textColor=HexColor("#1A1A2E"),
        spaceAfter=6,
    ))
    styles.add(ParagraphStyle(
        name="TARSSubtitle",
        fontName="Helvetica",
        fontSize=9,
        textColor=HexColor("#888888"),
        spaceAfter=20,
    ))
    styles.add(ParagraphStyle(
        name="TARSHeading",
        fontName="Helvetica-Bold",
        fontSize=14,
        textColor=HexColor("#1A1A2E"),
        spaceBefore=16,
        spaceAfter=8,
    ))
    styles.add(ParagraphStyle(
        name="TARSBody",
        fontName="Helvetica",
        fontSize=10,
        textColor=HexColor("#333333"),
        leading=14,
        spaceAfter=10,
    ))
    
    story = []
    
    # ── Title ──
    story.append(Paragraph(title, styles["TARSTitle"]))
    story.append(Paragraph(
        f"Generated by TARS · {datetime.now().strftime('%B %d, %Y at %I:%M %p')}",
        styles["TARSSubtitle"]
    ))
    story.append(HRFlowable(width="100%", thickness=1, color=HexColor("#D0D0D0")))
    story.append(Spacer(1, 12))
    
    # ── Sections ──
    for section in sections:
        if section.get("heading"):
            story.append(Paragraph(section["heading"], styles["TARSHeading"]))
        if section.get("body"):
            # Handle newlines
            body_text = section["body"].replace("\n", "<br/>")
            story.append(Paragraph(body_text, styles["TARSBody"]))
    
    # ── Table ──
    if table_data and table_data.get("headers") and table_data.get("rows"):
        story.append(Spacer(1, 16))
        
        data = [table_data["headers"]] + table_data["rows"]
        
        # Calculate column widths
        avail_width = letter[0] - 1.5*inch
        col_count = len(table_data["headers"])
        col_width = avail_width / col_count
        
        table = Table(data, colWidths=[col_width] * col_count)
        table.setStyle(TableStyle([
            # Header
            ("BACKGROUND", (0, 0), (-1, 0), HexColor("#1A1A2E")),
            ("TEXTCOLOR", (0, 0), (-1, 0), colors.white),
            ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
            ("FONTSIZE", (0, 0), (-1, 0), 10),
            ("ALIGN", (0, 0), (-1, 0), "CENTER"),
            ("BOTTOMPADDING", (0, 0), (-1, 0), 8),
            ("TOPPADDING", (0, 0), (-1, 0), 8),
            # Data rows
            ("FONTNAME", (0, 1), (-1, -1), "Helvetica"),
            ("FONTSIZE", (0, 1), (-1, -1), 9),
            ("TOPPADDING", (0, 1), (-1, -1), 6),
            ("BOTTOMPADDING", (0, 1), (-1, -1), 6),
            # Grid
            ("GRID", (0, 0), (-1, -1), 0.5, HexColor("#D0D0D0")),
            # Alternating rows
            *[("BACKGROUND", (0, i), (-1, i), HexColor("#F0F0F5")) 
              for i in range(2, len(data), 2)],
        ]))
        story.append(table)
    
    # ── Build ──
    doc.build(story)
    log.info(f"PDF report generated: {filepath}")
    
    return {
        "success": True,
        "path": filepath,
        "content": f"PDF report '{title}' saved to {filepath} ({len(sections)} sections)"
    }


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#  CSV Export
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

def generate_csv(title, headers, rows, filename=None):
    """Generate a CSV file for simple data export.
    
    Args:
        title: Used for filename if filename is None
        headers: Column headers
        rows: Data rows
        filename: Output filename
    
    Returns:
        dict with success, path, and content message
    """
    if not filename:
        safe_title = "".join(c if c.isalnum() or c in " _-" else "_" for c in title)
        filename = f"{safe_title}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    
    filepath = os.path.join(REPORT_DIR, filename)
    
    try:
        with open(filepath, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(headers)
            writer.writerows(rows)
        
        log.info(f"CSV report generated: {filepath}")
        return {
            "success": True,
            "path": filepath,
            "content": f"CSV report '{title}' saved to {filepath} ({len(rows)} rows)"
        }
    except Exception as e:
        return {"success": False, "error": True, "content": f"CSV generation failed: {e}"}


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#  Unified Entry Point
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

def generate_report(format_type, title, headers=None, rows=None, sections=None,
                    filename=None, summary=None, sheet_name="Report"):
    """Unified report generation. Called by the executor.
    
    Args:
        format_type: "excel", "pdf", "csv", or "chart"
        title: Report title
        headers: Column headers (for excel/csv/pdf table)
        rows: Data rows (for excel/csv/pdf table)
        sections: PDF sections list (for pdf)
        filename: Optional output filename
        summary: Optional summary dict (for excel)
        sheet_name: Sheet name (for excel)
    
    Returns:
        dict with success, path, and content
    """
    format_type = format_type.lower().strip()
    
    if format_type in ("excel", "xlsx", "xls"):
        if not headers or not rows:
            return {"success": False, "error": True,
                    "content": ("Excel needs 'headers' (list of column names) and 'rows' "
                                "(list of lists). Example: headers=['Stock','Price'], "
                                "rows=[['NVDA','$182'],['AMD','$207']]. "
                                "Or pass a 'data' dict and it will be auto-converted.")}
        return generate_excel(title, headers, rows, filename, sheet_name, summary)
    
    elif format_type == "pdf":
        if not sections:
            # Auto-create sections from table data if provided
            sections = [{"heading": title, "body": "Report generated by TARS."}]
        table_data = None
        if headers and rows:
            table_data = {"headers": headers, "rows": rows}
        return generate_pdf(title, sections, filename, table_data)
    
    elif format_type == "csv":
        if not headers or not rows:
            return {"success": False, "error": True,
                    "content": ("CSV needs 'headers' and 'rows'. "
                                "Or pass a 'data' dict and it will be auto-converted.")}
        return generate_csv(title, headers, rows, filename)
    
    elif format_type == "chart":
        return generate_chart(title, headers, rows, filename, summary)
    
    else:
        return {"success": False, "error": True,
                "content": f"Unknown format: {format_type}. Use 'excel', 'pdf', 'csv', or 'chart'."}


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#  Chart Generation (matplotlib)
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

def generate_chart(title, headers=None, rows=None, filename=None, chart_options=None):
    """Generate a chart image (PNG) using matplotlib.
    
    Args:
        title: Chart title
        headers: Column headers — first column is labels/x-axis, rest are data series
        rows: Data rows — [[label, val1, val2, ...], ...]
        filename: Output filename
        chart_options: Optional dict with:
            - "chart_type": "bar", "line", "pie", "scatter" (default: "bar")
            - "xlabel": X-axis label
            - "ylabel": Y-axis label
            - "figsize": [width, height] in inches
    
    Returns:
        dict with success, path, and content
    """
    try:
        import matplotlib
        matplotlib.use("Agg")  # Non-interactive backend
        import matplotlib.pyplot as plt
        import matplotlib.ticker as ticker
    except ImportError:
        return {"success": False, "error": True,
                "content": "matplotlib not installed. Run: pip install matplotlib"}

    if not headers or not rows:
        return {"success": False, "error": True,
                "content": "Chart needs 'headers' and 'rows'. First column = labels, rest = data series."}

    options = chart_options or {}
    chart_type = options.get("chart_type", "bar")
    figsize = options.get("figsize", [12, 7])

    try:
        # ── Parse data ──
        labels = [str(r[0]) for r in rows]
        series_names = headers[1:]  # Skip the label column header

        # Convert values to float (strip $, %, commas)
        def _to_float(v):
            if isinstance(v, (int, float)):
                return float(v)
            s = str(v).replace("$", "").replace(",", "").replace("%", "").strip()
            try:
                return float(s)
            except ValueError:
                return 0.0

        series_data = []
        for col_idx in range(1, len(headers)):
            series_data.append([_to_float(r[col_idx]) if col_idx < len(r) else 0 for r in rows])

        # ── Style ──
        plt.style.use("dark_background")
        fig, ax = plt.subplots(figsize=figsize)
        fig.patch.set_facecolor("#1A1A2E")
        ax.set_facecolor("#1A1A2E")

        colors = ["#00D4FF", "#FF6B6B", "#4ECDC4", "#FFE66D", "#A855F7",
                  "#F97316", "#22D3EE", "#E879F9", "#34D399", "#FB923C"]

        # ── Draw chart ──
        if chart_type == "bar":
            import numpy as np
            x = np.arange(len(labels))
            width = 0.8 / max(len(series_data), 1)
            for i, (data, name) in enumerate(zip(series_data, series_names)):
                offset = (i - len(series_data) / 2 + 0.5) * width
                bars = ax.bar(x + offset, data, width, label=name,
                             color=colors[i % len(colors)], alpha=0.9)
            ax.set_xticks(x)
            ax.set_xticklabels(labels, rotation=45, ha="right")

        elif chart_type == "line":
            for i, (data, name) in enumerate(zip(series_data, series_names)):
                ax.plot(labels, data, marker="o", linewidth=2, label=name,
                       color=colors[i % len(colors)])
            plt.xticks(rotation=45, ha="right")

        elif chart_type == "pie":
            # Use first data series only for pie
            data = series_data[0] if series_data else []
            pie_colors = colors[:len(data)]
            ax.pie(data, labels=labels, colors=pie_colors, autopct="%1.1f%%",
                  startangle=90, textprops={"color": "white"})

        elif chart_type == "scatter":
            for i, (data, name) in enumerate(zip(series_data, series_names)):
                ax.scatter(labels, data, s=100, label=name,
                          color=colors[i % len(colors)], alpha=0.8)
            plt.xticks(rotation=45, ha="right")

        # ── Labels & Legend ──
        ax.set_title(title, fontsize=16, fontweight="bold", color="white", pad=15)
        if options.get("xlabel"):
            ax.set_xlabel(options["xlabel"], color="#CCCCCC")
        if options.get("ylabel"):
            ax.set_ylabel(options["ylabel"], color="#CCCCCC")
        if len(series_names) > 1 and chart_type != "pie":
            ax.legend(facecolor="#2A2A3E", edgecolor="#444", labelcolor="white")

        ax.tick_params(colors="#CCCCCC")
        for spine in ax.spines.values():
            spine.set_color("#444")
        ax.grid(axis="y", alpha=0.2)

        plt.tight_layout()

        # ── Save ──
        if not filename:
            safe_title = "".join(c if c.isalnum() or c in " _-" else "_" for c in title)
            filename = f"chart_{safe_title}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"

        filepath = os.path.join(REPORT_DIR, filename)
        fig.savefig(filepath, dpi=150, bbox_inches="tight", facecolor=fig.get_facecolor())
        plt.close(fig)

        log.info(f"Chart generated: {filepath}")
        return {
            "success": True,
            "path": filepath,
            "content": f"Chart '{title}' saved to {filepath} ({chart_type}, {len(rows)} data points)"
        }

    except Exception as e:
        plt.close("all")
        return {"success": False, "error": True, "content": f"Chart generation error: {e}"}
